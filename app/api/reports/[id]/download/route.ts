
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth-config';
import { prisma } from '@/lib/db';
import { logActivity } from '@/lib/activity-logger';
import * as XLSX from 'xlsx';
import puppeteer from 'puppeteer';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const reportId = params.id;
    const { searchParams } = new URL(request.url);
    const format = searchParams.get('format') || 'pdf';

    // Get report
    const report = await prisma.report.findUnique({
      where: { id: reportId },
      include: {
        user: {
          select: { id: true, firstName: true, lastName: true, email: true, organizationId: true }
        },
        threatModel: {
          include: {
            findings: {
              select: {
                id: true,
                threatScenario: true,
                description: true,
                severity: true,
                strideCategory: true,
                status: true,
                nistControls: true,
                owaspCategory: true,
                cvssScore: true,
                asvsLevel: true,
                recommendation: true,
                createdAt: true
              }
            }
          }
        }
      }
    });

    if (!report) {
      return NextResponse.json(
        { error: 'Report not found' },
        { status: 404 }
      );
    }

    // Check permissions
    const isAdmin = ['ADMIN', 'BUSINESS_ADMIN'].includes(session.user.role);
    const isOwner = report.userId === session.user.id;
    const sameOrg = session.user.organizationId && 
      report.user.organizationId && 
      session.user.organizationId === report.user.organizationId;

    if (!isAdmin && !isOwner && !sameOrg) {
      return NextResponse.json(
        { error: 'Insufficient permissions' },
        { status: 403 }
      );
    }

    // Update download tracking
    await prisma.report.update({
      where: { id: reportId },
      data: {
        downloadCount: { increment: 1 },
        lastDownloaded: new Date()
      }
    });

    // Log activity
    await logActivity({
      userId: session.user.id,
      action: format === 'excel' ? 'EXPORT_EXCEL' : 'EXPORT_PDF',
      status: 'SUCCESS',
      description: `Downloaded ${format.toUpperCase()} report: ${report.name}`,
      entityType: 'report',
      entityId: report.id
    });

    if (format === 'excel') {
      return generateExcelReport(report);
    } else {
      return generatePDFReport(report);
    }

  } catch (error) {
    console.error('Error downloading report:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

async function generateExcelReport(report: any): Promise<NextResponse> {
  try {
    const workbook = XLSX.utils.book_new();

    // Summary sheet
    const summaryData = [
      ['Threat Model Report'],
      [''],
      ['Report Name', report.name],
      ['Threat Model', report.threatModel.name],
      ['Description', report.threatModel.description || 'N/A'],
      ['Generated On', new Date(report.createdAt).toLocaleDateString()],
      ['Generated By', `${report.user.firstName || ''} ${report.user.lastName || ''}`.trim() || report.user.email],
      [''],
      ['Summary'],
      ['Total Findings', report.threatModel.findings.length],
      ['Critical', report.threatModel.findings.filter((f: any) => f.severity === 'CRITICAL').length],
      ['High', report.threatModel.findings.filter((f: any) => f.severity === 'HIGH').length],
      ['Medium', report.threatModel.findings.filter((f: any) => f.severity === 'MEDIUM').length],
      ['Low', report.threatModel.findings.filter((f: any) => f.severity === 'LOW').length],
    ];

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

    // Findings sheet
    const findingsData = [
      [
        'ID', 'Title', 'Description', 'Severity', 'STRIDE Category', 
        'Status', 'CVSS Score', 'ASVS Level', 'OWASP Category', 
        'NIST Controls', 'Tags', 'False Positive', 'Not Applicable',
        'Recommendation', 'Created Date'
      ]
    ];

    report.threatModel.findings.forEach((finding: any) => {
      findingsData.push([
        finding.id,
        finding.title,
        finding.description,
        finding.severity,
        finding.strideCategory,
        finding.status,
        finding.cvssScore || 'N/A',
        finding.asvsLevel || 'N/A',
        finding.owaspCategory || 'N/A',
        finding.nistControls?.join(', ') || 'N/A',
        finding.tags?.join(', ') || 'N/A',
        finding.falsePositive ? 'Yes' : 'No',
        finding.notApplicable ? 'Yes' : 'No',
        finding.recommendation || 'N/A',
        new Date(finding.createdAt).toLocaleDateString()
      ]);
    });

    const findingsSheet = XLSX.utils.aoa_to_sheet(findingsData);
    XLSX.utils.book_append_sheet(workbook, findingsSheet, 'Findings');

    // Generate buffer
    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });

    return new NextResponse(buffer, {
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'Content-Disposition': `attachment; filename="${report.name.replace(/[^a-zA-Z0-9]/g, '_')}.xlsx"`,
        'Content-Length': buffer.length.toString(),
      },
    });

  } catch (error) {
    console.error('Error generating Excel report:', error);
    throw error;
  }
}

async function generatePDFReport(report: any): Promise<NextResponse> {
  let browser;
  
  try {
    // Create HTML content
    const htmlContent = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <title>${report.name}</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 20px; }
        .header { background: #1e40af; color: white; padding: 20px; text-align: center; margin-bottom: 30px; }
        .section { margin-bottom: 30px; }
        .finding { border: 1px solid #ddd; margin-bottom: 20px; padding: 15px; border-radius: 5px; }
        .severity-critical { border-left: 5px solid #dc2626; }
        .severity-high { border-left: 5px solid #ea580c; }
        .severity-medium { border-left: 5px solid #d97706; }
        .severity-low { border-left: 5px solid #2563eb; }
        .badge { display: inline-block; padding: 2px 8px; border-radius: 3px; font-size: 12px; margin: 2px; }
        .badge-critical { background: #fecaca; color: #991b1b; }
        .badge-high { background: #fed7aa; color: #9a3412; }
        .badge-medium { background: #fde68a; color: #92400e; }
        .badge-low { background: #dbeafe; color: #1e40af; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: #f8fafc; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Threat Model Security Report</h1>
        <h2>${report.name}</h2>
      </div>

      <div class="section">
        <h3>Executive Summary</h3>
        <table>
          <tr><th>Threat Model</th><td>${report.threatModel.name}</td></tr>
          <tr><th>Description</th><td>${report.threatModel.description || 'N/A'}</td></tr>
          <tr><th>Generated On</th><td>${new Date(report.createdAt).toLocaleDateString()}</td></tr>
          <tr><th>Generated By</th><td>${`${report.user.firstName || ''} ${report.user.lastName || ''}`.trim() || report.user.email}</td></tr>
          <tr><th>Total Findings</th><td>${report.threatModel.findings.length}</td></tr>
        </table>
      </div>

      <div class="section">
        <h3>Findings Summary</h3>
        <table>
          <tr>
            <th>Severity</th>
            <th>Count</th>
            <th>Percentage</th>
          </tr>
          ${['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].map(severity => {
            const count = report.threatModel.findings.filter((f: any) => f.severity === severity).length;
            const percentage = report.threatModel.findings.length > 0 ? 
              ((count / report.threatModel.findings.length) * 100).toFixed(1) : '0';
            return `
              <tr>
                <td><span class="badge badge-${severity.toLowerCase()}">${severity}</span></td>
                <td>${count}</td>
                <td>${percentage}%</td>
              </tr>
            `;
          }).join('')}
        </table>
      </div>

      <div class="section">
        <h3>Detailed Findings</h3>
        ${report.threatModel.findings.map((finding: any, index: number) => `
          <div class="finding severity-${finding.severity.toLowerCase()}">
            <h4>${index + 1}. ${finding.title}</h4>
            <p><strong>Severity:</strong> <span class="badge badge-${finding.severity.toLowerCase()}">${finding.severity}</span></p>
            <p><strong>STRIDE Category:</strong> ${finding.strideCategory}</p>
            <p><strong>Status:</strong> ${finding.status}</p>
            ${finding.cvssScore ? `<p><strong>CVSS Score:</strong> ${finding.cvssScore}</p>` : ''}
            ${finding.owaspCategory ? `<p><strong>OWASP Category:</strong> ${finding.owaspCategory}</p>` : ''}
            ${finding.nistControls?.length ? `<p><strong>NIST Controls:</strong> ${finding.nistControls.join(', ')}</p>` : ''}
            ${finding.tags?.length ? `<p><strong>Tags:</strong> ${finding.tags.join(', ')}</p>` : ''}
            ${finding.falsePositive ? '<p><strong>⚠️ Marked as False Positive</strong></p>' : ''}
            ${finding.notApplicable ? '<p><strong>ℹ️ Marked as Not Applicable</strong></p>' : ''}
            <p><strong>Description:</strong></p>
            <p>${finding.description}</p>
            ${finding.recommendation ? `
              <p><strong>Recommendation:</strong></p>
              <p>${finding.recommendation}</p>
            ` : ''}
          </div>
        `).join('')}
      </div>
    </body>
    </html>
    `;

    // Generate PDF with Puppeteer
    browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    const page = await browser.newPage();
    await page.setContent(htmlContent);
    
    const pdf = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: {
        top: '20mm',
        right: '20mm',
        bottom: '20mm',
        left: '20mm'
      }
    });

    await browser.close();

    return new NextResponse(pdf, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${report.name.replace(/[^a-zA-Z0-9]/g, '_')}.pdf"`,
        'Content-Length': pdf.length.toString(),
      },
    });

  } catch (error) {
    if (browser) {
      await browser.close();
    }
    console.error('Error generating PDF report:', error);
    throw error;
  }
}
